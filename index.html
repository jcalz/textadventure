<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=ascii">
  <title>Text Adventure</title>
  <link href="https://fonts.googleapis.com/css?family=VT323" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.1.1.js" integrity="sha256-16cdPddA6VdVInumRGo6IbivbERE8p7CQR3HzTBuELA=" crossorigin="anonymous"></script>
  <style>
    * {
      font-family: 'VT323', monospace;
      font-variant-ligatures: none;
      box-sizing: border-box;
      margin: 0;
    }

    html,
    body {
      height: 100%;
    }

    body {
      display: flex;
      flex-flow: column nowrap;
      align-items: stretch;
      overflow: hidden;
    }

    .header {
      text-align: center;
    }

    .adventure-window {
      flex: 1;
      border: 5px solid #0f0;
      padding: 5px;
      color: #0f0;
      background-color: black;
      font-size: 1.5em;
      display: flex;
      flex-flow: column-reverse nowrap;
      overflow: hidden;
    }

    .output {
      white-space: pre-wrap;
      overflow-wrap: break-word;
      overflow: auto;
    }

    .output-text {
      color: #ff0;
    }

    .error-text {
      color: #f00;
    }

    .input-line {
      display: flex;
      flex-flow: row nowrap;
      flex: 0 0 auto;
    }

    #input {
      flex: 1;
      border: none;
      outline: none;
      color: #0f0;
      background-color: black;
      font-size: 1em;
    }

    .filler {
      height: 100vh;
      display: inline-block;
    }
  </style>
</head>

<body>

  <div class="header">
    <h1>Text Adventure Game</h1>
  </div>
  <div class="adventure-window">
    <form autocomplete="off" class="input-line" id="adventure-form" onsubmit="processInput(); return false;">
      <label class="prompt" for="input">&gt;&gt;&nbsp;</label>
      <input type="text" id="input">
    </form>
    <div class="output" id="output">
      <span class="filler output-text"></span>
    </div>
  </div>

  <script>
    "use strict";
    //TODO FUTURE "you" should be more general
    //TODO state storage
    //TODO flesh out exits: description, hidden, etc
    //TODO "put ___ in/on ____"
    //TODO "use ___ with _____"
    //TODO default bidirectional exits.
    //TODO limit to inventory?
    //TODO "jump"
    // helper objects and functions 
    function moveCaretToEnd(el) {
      if (typeof el.selectionStart == "number") {
        el.selectionStart = el.selectionEnd = el.value.length;
      } else if (typeof el.createTextRange != "undefined") {
        el.focus();
        var range = el.createTextRange();
        range.collapse(false);
        range.select();
      }
    }

    function titleCase(str) {
      return str.toLowerCase().split(" ").map(function(v) {
        return v.charAt(0).toUpperCase() + v.slice(1);
      }).join(" ");
    }

    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    function series(strs, conjunction) {
      conjunction = conjunction || 'and';
      if (strs.length < 3) return strs.join(' ' + conjunction + ' ');
      return strs.slice(0, -1).join(', ') + ', ' + conjunction + ' ' + strs[strs.length - 1];
    }
    var vowelset = {
      "a": true,
      "e": true,
      "i": true,
      "o": true,
      "u": true
    };
    var directions = {
      north: ['n'],
      south: ['s'],
      east: ['e'],
      west: ['w'],
      northeast: ['ne'],
      southeast: ['se'],
      northwest: ['nw'],
      southwest: ['sw'],
      up: ['u'],
      down: ['d']
    };
    var dirs = {};
    Object.keys(directions).forEach(function(k) {
      dirs[k] = k;
      directions[k].forEach(function(v) {
        dirs[v] = k;
      });
    });
    // WORLD, GLOBAL VARIABLE
    var world = function() {
      var itemMap = {};
      return {
        add: function add(item) {
          var id = item.name.toLowerCase().replace(/[^a-z0-9_ ]/g, '').trim().replace(/\s+/g, '_');
          var cnt = 0;
          while (id in itemMap) {
            id = id + "" + cnt;
            cnt++;
          }
          itemMap[id] = item;
          item.id = id;
        },
        get items() {
          return Object.values(itemMap);
        },
        get itemMap() {
          return itemMap;
        }
      };
    }();

    function Item(name) {
      name = name || "item";
      this.name = name; // base name without definite/indefinite articles, lower case if possible.  try to make it unique.
      world.add(this);
      this.description = null; // optional string representing the verbose/examine description of the item.
      this.keywords = [this.name]; // list of words to identify this item.  try to make them unique.        
      this.definiteName = 'the ' + this.name; // definite version of the name
      this.indefiniteName = (this.name.charAt(0).toLowerCase() in vowelset ? "an " : "a ") + this.name;
      this.canBeTaken = true; // can you pick this up? 	  
      this.location = null; // optional Item representing the location of this item (part of the state)
      this.known = false; // part of the state
      this.hidden = false; // if it is hidden, you can't see it even if you're in the same room with it.
      this.exits = {}; // a list of mapping from directions to other places (uh, directions are strings?)
      this.beExaminedBy = function(subject) {
        var here = this;
        var ret = '';
        if (subject.location === here) {
          titleCase(this.name) + '\n';
        }
        ret += (this.description || 'It\s just ' + this.indefiniteName + '.');
        if (this.exits && Object.keys(this.exits).length > 0) {
          var es = Object.keys(this.exits);
          if (subject.location === here) {
            ret += ' There ';
            ret += es.length == 1 ? 'is an exit' : 'are exits';
          } else {
            ret += ' It has ';
            ret += es.length == 1 ? 'an exit' : 'exits';
          }
          ret += ' leading ';
          ret += series(es);
          ret += '.';
        }
        var items = world.items.filter(function(it) {
          return it !== subject && it.location === here && !it.hidden;
        });
        items.forEach(function(i) {
          i.known = true;
        });
        items = items.filter(function(it) {
          return !(it.unlisted)
        });
        items = items.map(function(it) {
          return it.indefiniteName;
        });
        if (items.length > 0) {
          if (subject.location === here) {
            ret += ' ' + capitalize(series(items)) + (items.length > 1 ? ' are' : ' is') + ' here.';
          } else {
            ret += ' It contains ' + series(items) + '.';
          }
        }
        return ret;
      };
      this.ultimatelyContains = function(item) {
        for (var loc = item.location; loc; loc = loc.location) {
          if (loc === this) return true;
        }
        return false;
      };
      this.ultimateLocation = function() {
        for (var loc = this; loc.location; loc = loc.location);
        return loc;
        // TODO INFINITE LOOP POSSIBILITY
      };
      this.canSee = function(item) {
        return !item.hidden && (this.ultimateLocation() === item.ultimateLocation());
      };
      this.has = function(item) {
        return !item.hidden && (this.ultimatelyContains(item));
      };
      // copy the state of this item into a string
      this.serialize = function() {
        //TODO			
      };
      // restore this item to the state represented by the passed-in string  
      this.deserialize = function(state) {
        //TODO
      };
    }

    function Place(name) {
      name = name || "place";
      Item.call(this, name);
      this.canBeTaken = false; // by default you can't pick up a place
    }
    // command structure
    function You(name) {
      name = name || "you";
      Item.call(this, name);
      this.indefiniteName = name;
      this.definiteName = name;
      this.canBeTaken = false; // by default you can't pick up yourself
      var go = function(dir) {
        if (!this.location || !this.location.exits || !(dir in this.location.exits)) {
          return "You can't go " + dir + " from here.";
        }
        this.location = this.location.exits[dir];
        return this.look();
      };
      go.templates = ['go ?d1', '?d1', 'move ?d1', 'walk ?d1'];
      go.help = 'Go in the specified direction, like North or South.';
      this.go = go;
      var climb = function() {
        return this.go('up');
      };
      climb.templates = ['climb', 'climb up'];
      this.climb = climb;
      var climbDown = function() {
        return this.go('down');
      };
      climbDown.templates = ['climb down'];
      this.climbDown = climbDown;
      var look = function look() {
        this.location.known = true;
        return this.location.beExaminedBy(this);
      };
      look.templates = ['look', 'l'];
      look.help = 'Look around you.';
      this.look = look;
      var take = function take(item) {
        if (!this.canSee(item)) {
          return "You can't see " + item.definiteName + " here.";
        }
        if (!item.canBeTaken) {
          return "You can't pick up " + item.definiteName + ".";
        }
        if (this.has(item)) {
          return "You already have " + item.definiteName + ".";
        }
        item.location = this;
        return "You have picked up " + item.definiteName + ".";
      };
      take.templates = ['take ?i1', 't ?i1', 'get ?i1', 'pick up ?i1', 'pickup ?i1', 'pick ?i1 up'];
      take.help = 'Pick up an item.';
      this.take = take;
      var drop = function drop(item) {
        if (!this.has(item)) {
          return "You don't have " + item.definiteName + ".";
        }
        item.location = this.location;
        return "You have dropped " + item.definiteName + ".";
      };
      drop.templates = ['drop ?i1', 'dr ?i1', 'put down ?i1', 'put ?i1 down', 'let ?i1 go', 'let go of ?i1',
        'let go ?i1', 'release ?i1'
      ];
      drop.help = 'Put down an item.';
      this.drop = drop;
      var inventory = function inventory() {
        var subject = this;
        var items = world.items.filter(function(item) {
          return subject.has(item);
        }).map(function(i) {
          return i.indefiniteName;
        });
        if (!items.length) return "You don't have anything.";
        return "You have " + series(items) + ".";
      };
      inventory.templates = ['inventory', 'i'];
      inventory.help = 'List the items in your possession.';
      this.inventory = inventory;
      var help = function help() {
        var ret = '';
        ret += 'Need help?  Here are some commands:\n';
        ret += this.commands().filter(function(c) {
          return c.help;
        }).map(function(c) {
          var shortcut = c.templates.find(function(t) {
            return t.split(/\s+/)[0].length == 1;
          });
          return '"' + c.templates[0].toLowerCase().split(/\s+/).map(function(x) {
            return x.startsWith('?i') ? '[ITEM]' : x.startsWith('?d') ? '[DIRECTION]' : capitalize(x);
          }).join(' ') + '": ' + c.help + (shortcut ? ' (Shortcut: "' + shortcut.charAt(0).toUpperCase() + '")' :
            '');
        }).join('\n');
        ret += '\nGood luck!';
        return ret;
      };
      help.templates = ['help', 'h', 'help me'];
      help.help = 'Read these words.';
      this.help = help;
      this.commands = function() {
        return Object.values(this).filter(function(v) {
          return typeof v == 'function' && 'templates' in v && v.templates.length > 0;
        });
      };
      this.addCommand = function(subjectCommandName, objectCommandName, templates, help) {
        var command = function command(object) {
          if (!this.canSee(object)) {
            return "You can't see " + object.definiteName + " here.";
          }
          if (!(objectCommandName in object)) {
            // okay let's use the first template
            var commandName = templates[0].split(/\s+/)[0].toLowerCase();
            return "You can't " + commandName + " " + object.definiteName + ".";
          }
          var args = Array.from(arguments);
          args[0] = this;
          return object[objectCommandName].apply(object, args);
        };
        command.templates = templates;
        if (help) {
          command.help = help;
        }
        this[subjectCommandName] = command;
      };
      this.addCommand('examine', 'beExaminedBy', ['examine ?i1', 'x ?i1', 'look ?i1', 'look at ?i1', 'l ?i1',
          'l at ?i1'
        ],
        'Examine an item.');
    }
    // parsing the input...command and an arity:  
    // 0: VERB
    // 1: VERB (PREPOSITION) OBJECT
    // 2: VERB OBJECT  OBJECT  
    // give object object  
    // parseItem(str) should return an item and the rest of the string.    
    function parseItem(str) {
      var ret = parseItemAndRemainder(str);
      if (!ret) return ret;
      return ret.item;
    }

    function interpretInput(str) {
      str = str.toLowerCase().replace(/[^a-z0-9 ]/g, '');
      str = str.replace(/\s+/g, ' ').trim();
      str = str.replace(/\bplease( |$)/g, '').trim(); // no need to be polite 
      // sort templates by length
      if (!interpretInput.templates) {
        interpretInput.templates = flatten(you.commands().map(function(c) {
          return c.templates.map(function(t) {
            return {
              func: c,
              pattern: t.toLowerCase().split(/\s+/)
            };
          });
        }));
        interpretInput.templates.sort(function(x, y) {
          return y.pattern.length - x.pattern.length;
        });
        //TODO maybe they should be ordered by number of item/dirs, or length of words?
      }
      templateLoop: for (var i = 0; i < interpretInput.templates.length; i++) {
        var template = interpretInput.templates[i];
        var m = str;
        var ret = {
          func: template.func,
          parameters: [],
          template: template.pattern.join(' ')
        };
        for (var j = 0; j < template.pattern.length; j++) {
          var token = template.pattern[j];
          if (token.charAt(0) == '?') {
            var paramIndex = parseInt(token.substring(2), 10) - 1;
            if (!(paramIndex >= 0)) {
              console.log('bad pattern index in: ' + template.pattern.join(' '));
              continue templateLoop;
            }
            var result;
            if (token.charAt(1) == 'i') {
              // interpret as an item
              result = parseItemAndRemainder(m);
              if (!result) continue templateLoop; // not an item
              ret.parameters[paramIndex] = result.item;
            } else if (token.charAt(1) == 'd') {
              // interpret as direction
              result = parseDirectionAndRemainder(m);
              if (!result) continue templateLoop; // not a direction
              ret.parameters[paramIndex] = result.direction;
            } else {
              // don't recognize the type of pattern word
              console.log('bad pattern type in: ' + template.pattern.join(' '));
              continue templateLoop;
            }
            m = result.remainder;
          } else {
            if (!(m + ' ').startsWith(token)) {
              // doesn't match
              continue templateLoop;
            }
            m = m.substring(token.length + 1); // remove a space or go off the end, which is fine				
          }
        }
        // we made it!  Or did we?  If there's stuff after the match, it's not a match
        if (m.length == 0) {
          return ret;
        }
      }
      return null; // no match
    }

    function flatten(arrayOfArray) {
      return [].concat.apply([], arrayOfArray);
    }

    function parseDirectionAndRemainder(str) {
      str = str.toLowerCase().replace(/^(the|a|an) /i, '').trim(); // strip off articles
      // TODO strip off "to" or "toward"?
      var space = (str + ' ').indexOf(' ');
      if (!space) return null; // no words
      var word = str.substring(0, space);
      var remainder = str.substring(space + 1);
      if (word in dirs) {
        return {
          direction: dirs[word],
          remainder: str.substring(space + 1)
        };
      }
      return null; // couldn't find direction
    }

    function parseItemAndRemainder(str) {
      str = str.toLowerCase().replace(/^(the|a|an) /i, ''); // strip off articles
      // get keywords for all known items
      var knownItems = flatten(world.items.filter(function(x) {
        return x.known;
      }).map(function(x) {
        return x.keywords.map(function(k) {
          return {
            keyword: k.toLowerCase(),
            canSee: you.canSee(x),
            item: x
          };
        });
      }));
      // sort these items so that nearby items are more likely to be identified,
      // and do the longest match first
      knownItems.sort(function(x, y) {
        if (x.canSee != y.canSee) {
          return x.canSee ? -1 : 1;
        }
        return y.keyword.length - x.keyword.length;
      });
      var found = knownItems.find(function(x) {
        return str.startsWith(x.keyword);
      });
      if (!found) return null;
      return {
        item: found.item,
        remainder: str.substring(found.keyword.length).trim()
      };
    }
    var blankResponses = ["What?", "Come again?", "Sorry, I didn't hear you.", "Did you say something?",
      "Are you confused?  Type \"help\" for help.", "I don't follow.", "You should probably type something.",
      "Sorry, I don't speak mime.", "Try using words to express yourself.",
      "I like short commands, but that's too short."
    ];
    var curBlankResponses = [];

    function respond(str) {
      str = str.replace(/\s+/g, ' ').trim();
      str = str.replace(/^"\s*(.*)\s*"$/, '$1');
      str = str.replace(/^'\s*(.*)\s*'$/, '$1');
      var interpretation = interpretInput(str);
      if (interpretation) {
        return interpretation.func.apply(you, interpretation.parameters);
      }
      // okay, we didn't understand.  So let's be humorous?
      if (str.length == 0) {
        if (!curBlankResponses.length) curBlankResponses = blankResponses.slice();
        return curBlankResponses.splice(Math.floor(Math.random() * curBlankResponses.length), 1)[0];
      }
      return "Sorry, I don't understand \"" + str + "\". Type \"help\" for help.";
    }
    // NEVER ALLOW THE FOCUS TO LEAVE THE INPUT BOX!  (seems evil)
    $('#input').blur(function() {
      window.setTimeout(function() {
        $('#input').focus();
      }, 0);
    });
    // IMPLEMENT COMMAND HISTORY WITH UP AND DOWN ARROWS		
    var commandHistory = function() {
      var history = [];
      var localHistory = [''];
      var index = 0;
      var add = function add(command) {
        // don't add duplicates, don't add blanks		
        if (command.length && (!history.length || history[history.length - 1] !== command)) {
          history.push(command);
        }
        index = history.length;
        localHistory = history.slice();
        localHistory.push('');
      };
      var arrow = function arrow(up, command) {
        localHistory[index] = command;
        if (up) {
          index = Math.max(index - 1, 0);
        } else {
          index = Math.min(index + 1, history.length);
        }
        return localHistory[index];
      };
      return {
        add: add,
        arrow: arrow
      };
    }();
    var KEYCODE_UP = 38;
    var KEYCODE_DOWN = 40;
    $('#input').keydown(function(e) {
      if (e.which == KEYCODE_UP || e.which == KEYCODE_DOWN) {
        var inputText = $('#input').val();
        var selectedCommand = commandHistory.arrow(e.which == KEYCODE_UP, inputText);
        $('#input').val(selectedCommand);
        moveCaretToEnd($('#input').get(0));
        e.preventDefault();
      }
    });
    $(function() {
      $('#input').focus();
      output("");
      output('Welcome to the game.\n\n' + you.look() + '\n');
    });

    function output(str, classNames) {
      classNames = classNames || 'output-text';
      $('#output').queue(function(next) {
        //console.log(str);
        var outputSpan = $('<span>').addClass(classNames);
        outputSpan.text(str + '\n');
        var o = $('#output');
        o.scrollTop(o.get(0).scrollHeight);
        var startTop = o.scrollTop();
        o.append(outputSpan);
        var millisPerWindow = 500;
        var pixelsPerMilli = $(window).height() / millisPerWindow;
        var start = null;
        var step = function step(time) {
          if (!start) start = time;
          var top = startTop + pixelsPerMilli * (time - start);
          o.scrollTop(top);
          if (Math.abs(o.scrollTop() - top) < 1) {
            window.requestAnimationFrame(step);
          } else {
            next();
          }
        };
        window.requestAnimationFrame(step);
      });
    }

    function processInput() {
      try {
        var inputText = $('#input').val();
        commandHistory.add(inputText);
        $('#input').val('');
        output('>>\xA0' + inputText, 'input-text');
        var outputText = respond(inputText);
        output(outputText + '\n');
      } catch (e) {
        output('ERROR: ' + JSON.stringify(e, Object.getOwnPropertyNames(e)) + '\n', 'error-text');
        if ("console" in window) console.log(e);
      }
    }
    ///////////// SPECIFIC STUFF /////////////////
    // YOU
    var you = new You();
    // silly template language: 
    // "use ?i1" means "use" followed by an ITEM, to be passed as FIRST parameter to the function.
    // "give ?i1 to ?i2", means "give"
    // "go ?d1" // d means DIRECTION
    you.addCommand('use', 'beUsedBy', ['use ?i1', 'use ?i1 with ?i2', 'use ?i1 on ?i2'], 'Use an item in some way.');
    you.addCommand('read', 'beReadBy', ['read ?i1'], 'Read something.');
    you.addCommand('eat', 'beEatenBy', ['eat ?i1']);
    you.addCommand('open', 'beOpenedBy', ['open ?i1', 'open ?i1 with ?i2', 'use ?i2 to open ?i1', 'open ?i1 using ?i2']);
    you.addCommand('move', 'beMovedBy', ['move ?i1']);
    you.addCommand('push', 'bePushedBy', ['push ?i1', 'shove ?i1', 'press ?i1', 'push on ?i1', 'press on ?i1']);
    you.addCommand('pull', 'bePulledBy', ['pull ?i1', 'tug ?i1', 'yank ?i1', 'pull on ?i1', 'tug on ?i1', 'yank on ?i1']);
    // PLACES
    var room = new Place("room");
    room.description = 'You are standing in a room with four walls, no furniture, and no windows.';
    var closet = new Place("closet");
    closet.description = 'You are standing inside of a closet. It is dim in here.  There is a heavy ' +
      'boulder up against the eastern wall.';
    var tunnel = new Place("underground tunnel");
    tunnel.description = 'You find yourself in an underground tunnel that you can stand in and walk. ' +
      'The walls of the tunnel are made out of stone.';
    tunnel.keywords.push('tunnel');
    var pit = new Place("pit");
    pit.description =
      'You are now at the bottom of a pit.  This pit is very deep.  The walls of the pit are also made of stone.';
    var bedroom = new Place("bedroom");
    bedroom.description = 'This room is big, with a huge bed covered in pink blankets.';
    you.location = room;
    // EXITS
    room.exits = {
      'north': closet,
      'south': bedroom
    };
    bedroom.exits = {
      'north': room
    };
    closet.exits = {
      'south': room //,
      //      'east': tunnel
    };
    tunnel.exits = {
      'west': closet,
      'east': pit
    };
    pit.exits = {
      'up': tunnel
    };
    // ITEMS
    var canOpener = new Item("can opener");
    canOpener.keywords.push('can opener', 'opener');
    canOpener.location = tunnel;
    canOpener.beUsedBy = function(subject, object) {
      if (!object) {
        if (subject.has(soup)) {
          return subject.open(soup, this);
        }
        if (!subject.has(this)) {
          return "You don't have " + this.definiteName + ".";
        }
        return "You can't use " + this.definiteName + " now.";
      }
      return subject.open(object, this);
    };
    var soup = new Item("can of soup");
    soup.keywords.push('can', 'soup', 'soup can', 'soupcan');
    soup.location = closet;
    soup.closed = true;
    soup.full = true;
    soup.beExaminedBy = function(subject) {
      if (!subject.has(this)) {
        return "It just looks like a can of soup from here.  Maybe you can examine it more closely if you pick it up.";
      }
      var ret = "The can is labeled \"NASS-TEE Split Pea Soup\". ";
      if (soup.closed) {
        ret += 'It is sealed shut.';
      } else if (soup.full) {
        ret += 'It is open and full of soup.';
      } else {
        ret += 'It is empty.';
      }
      return ret;
    };
    soup.beOpenedBy = function(subject, instrument) {
      if (!subject.has(this)) {
        return "You don't have " + this.definiteName + ".";
      }
      if (!this.closed) {
        return capitalize(this.definiteName) + " has already been opened.";
      }
      if (!instrument) {
        return "You try to rip the soup can open with your bare hands, but you can't.";
      }
      if (instrument !== canOpener) {
        return "You can't use " + instrument.definiteName + " to open " + this.definiteName + ".";
      }
      if (!subject.has(instrument)) {
        return "You don't have " + instrument.definiteName + ".";
      }
      this.closed = false;
      return "You successfully use " + instrument.definiteName + " to open " + this.definiteName + ".";
    }
    soup.beReadBy = function(subject) {
      if (!subject.has(this)) {
        return "It looks like there's writing on it, but you can't read it from here.";
      }
      return 'The soup can label is partially ripped off.  The part that\'s still there reads:\n' +
        '"NASS-TEE Split Pea Soup\n\n  If you like squished-up peas, you\'re sure to love these!\n' +
        '  Plop it in a bowl, or eat the can whole!\n' + '  It goes in as soup, but comes out as "';
    };
    soup.beUsedBy = function(subject, instrument) {
      if (!subject.has(this)) {
        return "You don't have " + this.definiteName + ".";
      }
      if (this.closed) {
        return this.beOpenedBy(subject, instrument);
      }
      if (!this.full) {
        return "You can't use the empty soup can.";
      }
      return this.beEatenBy(subject, instrument);
    };
    soup.beEatenBy = function(subject) {
      if (!subject.has(this)) {
        return "You have to pick up " + this.definiteName + " to eat it.";
      }
      if (this.closed) {
        return "You can't eat the sealed can.";
      }
      if (this.full) {
        this.full = false;
        return "You eat the soup.  Yum, tasty room-temperature soup!";
      }
      return "You can't eat it; the can is empty.";
    };
    var note = new Item("note");
    note.location = pit;
    note.beExaminedBy = function(subject) {
      if (!subject.has(this)) {
        return "It appears to have some writing on it, but you can't read it if you don't have it.";
      }
      return "There's definitely writing on it.";
    };
    note.beReadBy = function(subj) {
      if (!subj.has(this)) {
        return "You can't read it if you don't have it.";
      }
      return "The note reads:\n\n" +
        "\"Dear Mom,\n\nPlease do not eat the yummy NASS-TEE Split Pea Soup. I am saving it for dinner.\n" +
        "Love,\nElla.\"";
    };
    var bed = new Item("bed");
    bed.location = bedroom;
    bed.unlisted = true;
    bed.beExaminedBy = function(subject) {
      var ret = 'The bed is huge with pink blankets and purple pillows.';
      if (teddyBear.location === bed.location) {
        teddyBear.hidden = false; // reveal the teddy bear
        teddyBear.known = true;
        ret += ' There is a teddy bear on the bed.';
      }
      return ret;
    };
    bed.canBeTaken = false;
    bed.beUsedBy = function(subject) {
      return "You lie down on the bed and fall asleep for a few minutes.  You wake up feeling refreshed.";
    };
    var teddyBear = new Item("teddy bear");
    teddyBear.keywords = ['teddy bear', 'teddybear', 'teddy', 'bear'];
    teddyBear.location = bedroom;
    teddyBear.hidden = true;
    teddyBear.beExaminedBy = function(subject) {
      if (!subject.has(teddyBear)) {
        return 'The teddy bear is brown and wearing green overalls. You can\'t tell anything else about it from here.';
      }
      var ret = 'The teddy bear is brown and furry.  ' +
        'It is wearing green corduroy overalls with a pocket in the front.';
      if (key.location === this) {
        ret += ' As you turn the bear over in your hands, a key falls out of the pocket onto the ground.';
        key.location = subject.location;
        key.known = true;
      }
      return ret;
    }
    var key = new Item("key");
    key.keywords = ['key'];
    key.location = teddyBear;
    var boulder = new Item("boulder");
    boulder.keywords = ['boulder', 'bolder', 'rock', 'heavy boulder'];
    boulder.location = closet;
    boulder.unlisted = true;
    boulder.canBeTaken = false;
    boulder.budged = false;
    boulder.description = "This boulder is much too heavy for you to pick up.  " +
      "You might be able to move it a little, but that's about it.";
    boulder.beMovedBy = function(subject) {
      var ret = "";
      if (!boulder.budged) {
        boulder.budged = true;
        this.location.exits.east = tunnel;
        return "You bend down and push the boulder as hard as you can.  At first, it won't budge. " +
          "Finally, it starts moving along the wall, little by little.  Eventually you push it into " +
          "the corner where it stays.  You can't move it any further, and now you're sweaty and tired. " +
          "Why did you do this again?\n\nAnnoyed with yourself, you step back from the boulder and stand " +
          "up again... to see that the boulder had been blocking an exit on the eastern wall, which is now " +
          "revealed!"
      }
      return "The boulder is completely wedged in the corner now.  It's not going anywhere.";
    }
    boulder.bePushedBy = boulder.beMovedBy;
    boulder.bePulledBy = boulder.beMovedBy;
  </script>
</body>

</html>
