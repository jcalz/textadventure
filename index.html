<html>

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=ascii">
  <title>Text Adventure</title>
  <link href="https://fonts.googleapis.com/css?family=VT323" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.1.1.js" integrity="sha256-16cdPddA6VdVInumRGo6IbivbERE8p7CQR3HzTBuELA=" crossorigin="anonymous"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa"
    crossorigin="anonymous"></script>
  <style>
    html * {
      font-family: 'VT323', monospace;
      font-variant-ligatures: none;
      padding: 0;
      margin: 0;
    }

    #adventure-window {
      width: 90% height: 90%;
      border: 5px solid #0f0;
      padding: 5px;
      color: #0f0;
      background-color: black;
      font-size: 1.5em;
    }

    .output-span {
      color: #ff0;
    }

    .bottom-container {
      position: relative;
      width: 100%;
      height: 85%;
      overflow: hidden;
    }

    #output {
      position: absolute;
      bottom: 0px;
      overflow: hidden;
      width: 100%;
    }

    #output span {
      white-space: pre-wrap;
      overflow-wrap: break-word;
    }

    #input {
      border: none;
      color: #0f0;
      background-color: black;
      font-size: 1em;
      flex-grow: 100;
    }

    #adventure-form {
      display: flex;
    }

    .prompt {
      float: left;
    }
  </style>
</head>

<body>
  <div>
    <h1>Text Adventure Game</h1>
    <div id="adventure-window">
      <div class="bottom-container">
        <div id="output"></div>
      </div>
      <form autocomplete="off" id="adventure-form" onsubmit="processInput(); return false;">
        <label class="prompt" for="input">&gt;&gt;&nbsp;</label>
        <input type="text" id="input">
      </form>
    </div>
  </div>
</body>
<script>
  "use strict";
  //TODO scroll history
  //TODO climb = "go up" ?
  //TODO FUTURE "you" should be more general
  //TODO state storage
  //TODO "read" command
  //TODO flesh out exits: description, hidden, etc
  //TODO parse multiple objects
  //TODO "put ___ in/on ____"
  //TODO "use ___ with _____"
  //TODO items: visible,hidden,already described in the room, etc.
  //TODO default bidirectional exits.
  //TODO limit to inventory?
  //TODO generic command functions
  // helper objects and functions 
  function moveCaretToEnd(el) {
    if (typeof el.selectionStart == "number") {
      el.selectionStart = el.selectionEnd = el.value.length;
    } else if (typeof el.createTextRange != "undefined") {
      el.focus();
      var range = el.createTextRange();
      range.collapse(false);
      range.select();
    }
  }

  function titleCase(str) {
    return str.toLowerCase().split(" ").map(function(v) {
      return v.charAt(0).toUpperCase() + v.slice(1);
    }).join(" ");
  }

  function capitalize(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }

  function series(strs, conjunction) {
    conjunction = conjunction || 'and';
    if (strs.length < 3) return strs.join(' ' + conjunction + ' ');
    return strs.slice(0, -1).join(', ') + ', ' + conjunction + ' ' + strs[
      strs.length - 1];
  }
  var vowelset = {
    "a": true,
    "e": true,
    "i": true,
    "o": true,
    "u": true
  };
  var directions = {
    north: ['n'],
    south: ['s'],
    east: ['e'],
    west: ['w'],
    northeast: ['ne'],
    southeast: ['se'],
    northwest: ['nw'],
    southwest: ['sw'],
    up: ['u'],
    down: ['d']
  };
  var dirs = {};
  Object.keys(directions).forEach(function(k) {
    dirs[k] = k;
    directions[k].forEach(function(v) {
      dirs[v] = k;
    });
  });
  // WORLD, GLOBAL VARIABLE
  var world = function() {
    var itemMap = {};
    return {
      add: function add(item) {
        var id = item.name.toLowerCase().replace(/[^a-z0-9_ ]/g, '').trim()
          .replace(/\s+/g, '_');
        var cnt = 0;
        while (id in itemMap) {
          id = id + "" + cnt;
          cnt++;
        }
        itemMap[id] = item;
        item.id = id;
      },
      get items() {
        return Object.values(itemMap);
      },
      get itemMap() {
        return itemMap;
      }
    };
  }();

  function Item(name) {
    name = name || "item";
    this.name = name; // base name without definite/indefinite articles, lower case if possible.  try to make it unique.
    world.add(this);
    this.location = null; // optional Item representing the location of this item (part of the state)
    this.description = null; // optional string representing the verbose/examine description of the item.
    this.keywords = [this.name]; // list of words to identify this item.  try to make them unique.        
    this.definiteName = 'the ' + this.name; // definite version of the name
    this.indefiniteName = (this.name.charAt(0).toLowerCase() in vowelset ?
      "an " : "a ") + this.name;
    this.canBeTaken = true; // can you pick this up? 	  
    this.beUsed = function() {
      return "You can't use " + this.definiteName + ".";
    };
    this.known = false; // part of the state
    this.describe = function() {
      var ret = this.description || 'It\'s just ' + this.indefiniteName +
        '.';
      return ret;
    };
    // copy the state of this item into a string
    this.serialize = function() {
      //TODO			
    };
    // restore this item to the state represented by the passed-in string  
    this.deserialize = function(state) {
      //TODO
    };
  }

  function Place(name) {
    name = name || "place";
    Item.call(this, name);
    this.canBeTaken = false; // by default you can't pick up a place
    this.exits = {}; // a list of mapping from directions to other Places (uh, directions are strings?)
    this.describe = function() {
      var _this = this;
      var ret = titleCase(this.name) + '\n' + (this.description || '') +
        ' ';
      if (this.exits && Object.keys(this.exits).length > 0) {
        var es = Object.keys(this.exits);
        ret += 'There ';
        ret += es.length == 1 ? 'is an exit' : 'are exits';
        ret += ' leading ';
        ret += series(es);
        ret += '.';
      }
      var items = world.items.filter(function(it) {
        return it !== you && it.location === _this;
      });
      items.forEach(function(i) {
        i.known = true;
      });
      if (items.length > 0) {
        ret += ' ' + capitalize(series(items.map(function(x) {
          return x.indefiniteName;
        }))) + (items.length > 1 ? ' are' : ' is') + ' here.';
      }
      return ret;
    };
  }

  // silly template language: 
  // "use ?i1" means "use" followed by an ITEM, to be passed as FIRST parameter to the function.
  // "give ?i1 to ?i2", means "give"
  // "go ?d1" // d means DIRECTION
  // command structure
  var commands = [{
      functionName: 'look',
      templates: ['look', 'l'],
      help: '"Look" or "L": Look around you.'
    },
    {
      functionName: 'move',
      templates: ['?d1', 'go ?d1', 'move ?d1', 'walk ?d1'],
      help: '"Go [DIRECTION]" or "[DIRECTION]": Go in the specified direction.\n' +
        '... examples: "Go North"/"North"/"N", "Go South"/"South"/"S", "East"'

    },
    {
      functionName: 'inventory',
      templates: ['inventory', 'i'],
      help: '"Inventory" or "I": List the items in your possession'
    },
    {
      functionName: 'take',
      templates: ['take ?i1', 't ?i1', 'get ?i1', 'pick up ?i1', 'pickup ?i1', 'pick ?i1 up'],
      help: '"Take [ITEM]" or "T [ITEM]": Pick up an item.'
    },
    {
      functionName: 'drop',
      templates: ['drop ?i1', 'dr ?i1', 'put down ?i1', 'put ?i1 down', 'let ?i1 go', 'let go of ?i1', 'let go ?i1',
        'release ?i1'
      ],
      help: '"Drop [ITEM]" or "DR [ITEM]": Put down an item.'
    },
    {
      functionName: 'examine',
      templates: ['examine ?i1', 'x ?i1', 'look ?i1', 'look at ?i1', 'l ?i1', 'l at ?i1'],
      help: '"Examine [ITEM]" or "X [ITEM]": Examine an item.'
    },
    {
      functionName: 'use',
      templates: ['use ?i1'],
      help: '"Use [ITEM]": Use an item in some way.'
    },
    {
      functionName: 'help',
      templates: ['help', 'h'],
      help: '"Help" or "H": Read these words.'
    }
  ];

  function You(name) {
    name = name || "you";
    Item.call(this, name);
    this.indefiniteName = name;
    this.definiteName = name;
    this.canBeTaken = false; // by default you can't pick up yourself
    this.move = function(dir) {
      if (!this.location || !this.location.exits || !(dir in this.location.exits)) {
        return "You can't go " + dir + " from here.";
      }
      this.location = this.location.exits[dir];
      return this.look();
    };
    this.look = function() {
      this.location.known = true;
      return this.location.describe();
    };
    this.glance = function() {
      return titleCase(this.location.name);
    };
    this.canSee = function(item) {
      return item.location === this.location || item === this.location ||
        item.location === this;
    };
    this.has = function(item) {
      return item.location === this;
    }
    this.examine = function(item) {
      if (!this.canSee(item)) {
        return "You can't see " + item.definiteName + " here.";
      }
      return item.describe();
    };
    this.take = function(item) {
      if (!this.canSee(item)) {
        return "You can't see " + item.definiteName + " here.";
      }
      if (!item.canBeTaken) {
        return "You can't pick up " + item.definiteName + ".";
      }
      if (this === item.location) {
        return "You already have " + item.definiteName + ".";
      }
      item.location = this;
      return "You have picked up " + item.definiteName + ".";
    };
    this.drop = function(item) {
      if (this !== item.location) {
        return "You don't have " + item.definiteName + ".";
      }
      item.location = this.location;
      return "You have dropped " + item.definiteName + ".";
    };
    this.inventory = function() {
      var _this2 = this;
      var items = world.items.filter(function(i) {
        return i.location === _this2;
      }).map(function(i) {
        return i.indefiniteName;
      });
      if (!items.length) return "You don't have anything.";
      return "You have " + series(items) + ".";
    };
    this.use = function(item) {
      if (!this.canSee(item)) {
        return "You can't see " + item.definiteName + " here.";
      }
      return item.beUsed();
    };
    this.help = function() {
      var ret = '';
      ret += 'Need help?  Here are some commands:\n';
      ret += commands.filter(c => c.help).map(c => c.help).join('\n');
      ret += '\nGood luck!';
      return ret;
    };

  }
  // parsing the input...command and an arity:  
  // 0: VERB
  // 1: VERB (PREPOSITION) OBJECT
  // 2: VERB OBJECT  OBJECT  
  // give object object  
  // parseItem(str) should return an item and the rest of the string.    
  function parseItem(str) {
    var ret = parseItemAndRemainder(str);
    if (!ret) return ret;
    return ret.item;
  }

  function interpretInput(str) {

    str = str.toLowerCase().replace(/[^a-z0-9 ]/g, '');
    str = str.replace(/\s+/g, ' ').trim();
    str = str.replace(/\bplease( |$)/g, '').trim(); // no need to be polite 

    // sort templates by length
    if (!interpretInput.templates) {
      interpretInput.templates = flatten(commands.map(c => c.templates.map(t => ({
        functionName: c.functionName,
        pattern: t.toLowerCase().split(/\s+/)
      }))));
      interpretInput.templates.sort((x, y) => (y.pattern.length - x.pattern.length));
      //TODO maybe they should be ordered by number of item/dirs, or length of words?
    }

    templateLoop:
      for (var i = 0; i < interpretInput.templates.length; i++) {
        var template = interpretInput.templates[i];
        var m = str;
        var ret = {
          functionName: template.functionName,
          parameters: [],
          template: template.pattern.join(' ')
        };
        for (var j = 0; j < template.pattern.length; j++) {
          var token = template.pattern[j];
          if (token.charAt(0) == '?') {
            var paramIndex = parseInt(token.substring(2), 10) - 1;
            if (!(paramIndex >= 0)) {
              console.log('bad pattern index in: ' + template.pattern.join(' '));
              continue templateLoop;
            }
            var result;
            if (token.charAt(1) == 'i') {
              // interpret as an item
              result = parseItemAndRemainder(m);
              if (!result) continue templateLoop; // not an item
              ret.parameters[paramIndex] = result.item;
            } else if (token.charAt(1) == 'd') {
              // interpret as direction
              result = parseDirectionAndRemainder(m);
              if (!result) continue templateLoop; // not a direction
              ret.parameters[paramIndex] = result.direction;
            } else {
              // don't recognize the type of pattern word
              console.log('bad pattern type in: ' + template.pattern.join(' '));
              continue templateLoop;
            }
            m = result.remainder;
          } else {
            if (!(m + ' ').startsWith(token)) {
              // doesn't match
              continue templateLoop;
            }
            m = m.substring(token.length + 1); // remove a space or go off the end, which is fine				
          }
        }
        // we made it!  Or did we?  If there's stuff after the match, it's not a match
        if (m.length == 0) {
          return ret;
        }

      }
    return null; // no match

  }

  function flatten(arrayOfArray) {
    return [].concat.apply([], arrayOfArray);
  }

  function parseDirectionAndRemainder(str) {
    str = str.toLowerCase().replace(/^(the|a|an) /i, '').trim(); // strip off articles
    // TODO strip off "to" or "toward"?

    var space = (str + ' ').indexOf(' ');
    if (!space) return null; // no words

    var word = str.substring(0, space);
    var remainder = str.substring(space + 1);

    if (word in dirs) {
      return {
        direction: dirs[word],
        remainder: str.substring(space + 1)
      }
    }

    return null; // couldn't find direction
  }

  function parseItemAndRemainder(str) {
    str = str.toLowerCase().replace(/^(the|a|an) /i, ''); // strip off articles
    // get keywords for all known items
    var knownItems = flatten(world.items.filter(function(x) {
      return x.known;
    }).map(function(x) {
      return x.keywords.
      map(function(k) {
        return {
          keyword: k.toLowerCase(),
          canSee: you.canSee(x),
          item: x
        };
      });
    }));
    // sort these items so that nearby items are more likely to be identified,
    // and do the longest match first
    knownItems.sort(function(x, y) {
      if (x.canSee != y.canSee) {
        return x.canSee ? -1 : 1;
      }
      return y.keyword.length - x.keyword.length;
    });
    var found = knownItems.find(function(x) {
      return str.startsWith(x.keyword);
    });
    if (!found) return null;
    return {
      item: found.item,
      remainder: str.substring(found.keyword.length).trim()
    };
  }

  function respond(str) {
    str = str.replace(/\s+/g, ' ').trim();
    str = str.replace(/^"\s*(.*)\s*"$/, '$1');
    str = str.replace(/^'\s*(.*)\s*'$/, '$1');

    var interpretation = interpretInput(str);

    if (interpretation) {
      //console.log(interpretation);
      return you[interpretation.functionName].apply(you, interpretation.parameters);
    }

    return "Sorry, I don't understand \"" + str +
      "\". Type \"help\" for help.";
  }

  // NEVER ALLOW THE FOCUS TO LEAVE THE INPUT BOX!  (seems evil)
  $('#input').blur(function() {
    window.setTimeout(function() {
      $('#input').focus();
    }, 0)
  });
  // IMPLEMENT COMMAND HISTORY WITH UP AND DOWN ARROWS		
  var commandHistory = (function() {
    var history = [];
    var localHistory = [''];
    var index = 0;
    var add = function(command) {
      history.push(command);
      index = history.length;
      localHistory = history.slice();
      localHistory.push('');
    };
    var arrow = function(up, command) {
      localHistory[index] = command;
      if (up) {
        index = Math.max(index - 1, 0);
      } else {
        index = Math.min(index + 1, history.length);
      }
      return localHistory[index];
    };
    return {
      add: add,
      arrow: arrow
    };
  })();
  var KEYCODE_UP = 38;
  var KEYCODE_DOWN = 40;
  $('#input').keydown(function(e) {
    if ((e.which == KEYCODE_UP) || (e.which == KEYCODE_DOWN)) {
      var inputText = $('#input').val();
      var selectedCommand = commandHistory.arrow(e.which == KEYCODE_UP,
        inputText);
      $('#input').val(selectedCommand);
      moveCaretToEnd($('#input').get(0));
      e.preventDefault();
    }
  });
  $(function() {
    $('#input').focus();
    output("");
    output('Welcome to the game.\n\n' + you.look() + '\n');
  });

  function output(str) {
    var outputSpan = $('<span class="output-span">').css('visibility',
      'hidden');
    outputSpan.text(str + '\n');
    $('#output').queue(function(next) {
      $('#output').append(outputSpan);
      var heightFrac = outputSpan.height() / $(window).height();
      outputSpan.hide().css('visibility', 'visible');
      var duration = heightFrac * 3000;
      outputSpan.slideDown({
        duration: duration,
        easing: 'linear',
        complete: next
      });
    });
  }

  function processInput() {
    var inputText = $('#input').val();
    commandHistory.add(inputText);
    $('#input').val('');
    var inputSpan = $('<span>');
    inputSpan.text(">>\xA0" + inputText + '\n');
    $('#output').queue(function(next) {
      $('#output').append(inputSpan);
      next();
    });
    var outputText = respond(inputText);
    output(outputText + '\n');
  }

  ///////////// SPECIFIC STUFF /////////////////

  // YOU
  var you = new You();
  // PLACES
  var room = new Place("room");
  room.description =
    'You are standing in a room with four walls, no furniture, and no windows.';
  var closet = new Place("closet");
  closet.description =
    'You are standing inside of a closet. It is dim in here.';
  var tunnel = new Place("underground tunnel");
  tunnel.description =
    'You find yourself in an underground tunnel that you can stand in and walk. ' +
    'The walls of the tunnel are made out of stone.';
  tunnel.keywords.push('tunnel');
  var pit = new Place("pit");
  pit.description =
    'You are now at the bottom of a pit.  This pit is very deep.  The walls of the pit are also made of stone.';
  var bedroom = new Place("bedroom");
  bedroom.description =
    'This room is big, with a huge bed covered in pink blankets.';
  you.location = room;
  // EXITS
  room.exits = {
    'north': closet,
    'south': bedroom
  };
  bedroom.exits = {
    'north': room
  };
  closet.exits = {
    'south': room,
    'east': tunnel
  };
  tunnel.exits = {
    'west': closet,
    'east': pit
  };
  pit.exits = {
    'up': tunnel
  };
  // ITEMS
  var soup = new Item("can of soup");
  soup.keywords.push('can', 'soup', 'soup can', 'soupcan');
  soup.location = closet;
  soup.closed = true;
  soup.full = true;
  soup.origDescribe = soup.describe;
  soup.describe = function() {
    if (!you.has(this)) {
      return "It just looks like a can of soup from here.  Maybe you can examine it more closely if you pick it up.";
    }
    var ret = "The can is labeled \"NASS-TEE Split Pea Soup\". ";
    if (soup.closed) {
      ret += 'It is sealed shut.';
    } else if (soup.full) {
      ret += 'It is open and full of soup.';
    } else {
      ret += 'It is empty.';
    }
    return ret;
  };
  soup.beUsed = function() {
    if (!you.has(this)) {
      return "You don't have " + this.definiteName + ".";
    }
    if (this.closed) {
      this.closed = false;
      return "You rip the soup can open with your bare hands, somehow.";
    }
    if (!this.full) {
      return "You can't use the empty soup can.";
    }
    this.full = false;
    return "You eat the soup.  Yum, tasty room-temperature soup!";
  };
  var note = new Item("note");
  note.location = pit;
  note.describe = function() {
    if (!you.has(this)) {
      return "It appears to have some writing on it, but you can't read it if you don't have it.";
    }
    return "The note reads:\n\n" +
      "\"Dear Mom,\n\nPlease do not eat the yummy NASS-TEE Split Pea Soup. I am saving it for dinner.\n" +
      "Love,\nElla.\"";
  }
  var bed = new Item("bed");
  bed.location = bedroom;
  bed.describe = function() {
    //TODO find better way to hide stuff than this
    var ret = 'The bed is huge with a purple blanket and pink pillows.';
    if (teddyBear.location === bed) {
      teddyBear.location = bed.location;
      teddyBear.known = true;
    }
    if (teddyBear.location === bed.location) {
      ret += ' There is a teddy bear on the bed.';
    }
    return ret;
  };
  bed.canBeTaken = false;
  bed.beUsed = function() {
    return "You lie down on the bed and fall asleep for a few minutes.  You wake up feeling refreshed.";
  }
  var teddyBear = new Item("teddy bear");
  teddyBear.keywords = ['teddy bear', 'teddybear', 'teddy', 'bear'];
  teddyBear.location = bed;
</script>

</html>
